var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

import { OgodSceneChanges } from "../state/ogod-scene-changes.js";

const resourceReducer = function (state = {}, action) {
  let payload = action.payload;

  switch (action.type) {
    case 'RESOURCE_CREATE':
      return Object.assign(Object.assign({}, state), {
        [payload.name]: payload.state
      });

    case 'RESOURCE_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.name]: Object.assign(Object.assign({}, state[payload.name]), {
          entity: Object.assign(Object.assign({}, state[payload.name].entity), {
            loading: true
          })
        })
      });

    case 'RESOURCE_LOADED':
      return Object.assign(Object.assign({}, state), {
        [payload.name]: Object.assign(Object.assign({}, state[payload.name]), {
          entity: Object.assign(Object.assign({}, state[payload.name].entity), {
            loading: false,
            loaded: true
          })
        })
      });

    case 'RESOURCE_DESTROY':
      state[payload.name].runtime.destroy(state[payload.name].entity);

      let _a = payload.name,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;
  }

  return state;
};

const instanceReducer = function (state = {}, action) {
  let payload = action.payload;
  let instance = state[payload && payload.id];

  switch (action.type) {
    case 'INSTANCE_CREATE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: payload.state
      });

    case 'INSTANCE_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
          entity: Object.assign(Object.assign({}, state[payload.id].entity), {
            loading: true
          })
        })
      });

    case 'INSTANCE_LOADED':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
          entity: Object.assign(Object.assign({}, state[payload.id].entity), {
            loading: false,
            loaded: true
          })
        })
      });

    case 'INSTANCE_INITIALIZE':
      let entity = state[payload.id].runtime.initialize(state[payload.id].entity);
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
          entity
        })
      });

    case 'INSTANCE_DESTROY':
      state[payload.id].runtime.destroy(state[payload.id].entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;

    case 'INSTANCE_UPDATE':
      let modified = payload.changes instanceof OgodSceneChanges && payload.changes._modified;
      Object.keys(modified).forEach(key => {
        let newProps = Object.assign(Object.assign({}, state[key].entity.properties), modified[key].properties);
        state[key] = {
          entity: Object.assign(Object.assign(Object.assign({}, state[key].entity), modified[key]), {
            properties: newProps
          }),
          runtime: state[key].runtime
        };
      });
      break;

    case 'INSTANCE_CHANGES':
      let newEntity = instance.runtime.changes(instance.entity, payload.changes);

      if (instance.entity !== newEntity) {
        return Object.assign(Object.assign({}, state), {
          [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
            entity: Object.assign(Object.assign({}, state[payload.id].entity), newEntity)
          })
        });
      }

      break;

    case 'INSTANCE_CHANGES_PROPERTY':
      let curProp = instance.entity.properties[payload.changes.name].entity;
      let newProp = instance.runtime.changesProperty(instance.entity, payload.changes);

      if (curProp !== newProp) {
        return Object.assign(Object.assign({}, state), {
          [payload.id]: Object.assign(Object.assign({}, instance), {
            entity: Object.assign(Object.assign({}, instance.entity), {
              properties: Object.assign(Object.assign({}, instance.entity.properties), {
                [payload.changes.name]: {
                  runtime: instance.entity.properties[payload.changes.name].runtime,
                  entity: newProp
                }
              })
            })
          })
        });
      }

      break;

    case 'INSTANCE_PROPERTY_ADD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, instance), {
          entity: Object.assign(Object.assign({}, instance.entity), {
            properties: Object.assign(Object.assign({}, instance.entity.properties), {
              [payload.propName]: payload.changes
            })
          })
        })
      });

    case 'INSTANCE_PROPERTY_REMOVE':
      let _b = instance.entity.properties,
          _c = payload.propName,
          removed = _b[_c],
          newProps = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);

      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, instance), {
          entity: Object.assign(Object.assign({}, instance.entity), {
            properties: newProps
          })
        })
      });

    case 'INSTANCE_REPLACE_PROPERTY':
      let replaced = payload.changes;
      let replacedProp = instance.runtime.changesProperty(Object.assign(Object.assign({}, instance.entity), {
        properties: Object.assign(Object.assign({}, instance.entity.properties), {
          [payload.propName]: replaced
        })
      }), replaced.entity);
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, instance), {
          entity: Object.assign(Object.assign({}, instance.entity), {
            properties: Object.assign(Object.assign({}, instance.entity.properties), {
              [payload.propName]: {
                runtime: replaced.runtime,
                entity: replacedProp
              }
            })
          })
        })
      });
  }

  return state;
};

const sceneReducer = function (state = {}, action) {
  const payload = action.payload;
  const scene = state[payload && payload.id];

  switch (action.type) {
    case 'SCENE_CREATE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: payload.state
      });

    case 'SCENE_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
          entity: Object.assign(Object.assign({}, state[payload.id].entity), {
            loading: true
          })
        })
      });

    case 'SCENE_LOADED':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, state[payload.id]), {
          entity: Object.assign(Object.assign({}, state[payload.id].entity), {
            loading: false,
            loaded: true
          })
        })
      });

    case 'SCENE_CHANGES':
      let changed = scene.runtime.changes(scene.entity, payload.changes);

      if (scene.entity !== changed) {
        return Object.assign(Object.assign({}, state), {
          [payload.id]: Object.assign(Object.assign({}, scene), {
            entity: changed
          })
        });
      }

    case 'SCENE_ADD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, scene), {
          entity: scene.runtime.add(scene.entity, payload.childId, payload.zIndex)
        })
      });

    case 'SCENE_REMOVE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, scene), {
          entity: scene.runtime.remove(scene.entity, payload.childId)
        })
      });

    case 'SCENE_DESTROY':
      scene.runtime.destroy(scene.entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;
  }

  return state;
};

const engineReducer = function (state = {}, action) {
  let payload = action.payload;
  let engine = state[payload && payload.id];

  switch (action.type) {
    case 'ENGINE_CREATE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: payload.state
      });

    case 'ENGINE_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, engine), {
          entity: Object.assign(Object.assign({}, engine.entity), {
            loading: true
          })
        })
      });

    case 'ENGINE_LOADED':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, engine), {
          entity: Object.assign(Object.assign({}, engine.entity), {
            loading: false,
            loaded: true
          })
        })
      });

    case 'ENGINE_START':
      if (!engine.entity.started) {
        return Object.assign(Object.assign({}, state), {
          [payload.id]: {
            entity: engine.runtime.start(engine.entity),
            runtime: engine.runtime
          }
        });
      } else {
        console.warn('Cannot start engine if already started');
        return state;
      }

    case 'ENGINE_STOP':
      if (engine.entity.started) {
        return Object.assign(Object.assign({}, state), {
          [payload.id]: {
            entity: engine.runtime.stop(engine.entity),
            runtime: engine.runtime
          }
        });
      } else {
        console.warn('Cannot stop engine if already stopped');
        return state;
      }

    case 'ENGINE_PAUSE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: {
          entity: engine.runtime.pause(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_RESUME':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: {
          entity: engine.runtime.resume(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_TOGGLE_PAUSE':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: {
          entity: engine.entity.paused ? engine.runtime.resume(engine.entity) : engine.runtime.pause(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_DESTROY':
      state[payload.id].runtime.destroy(state[payload.id].entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;

    case 'ENGINE_RENDERER_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, engine), {
          entity: engine.runtime.loadRenderer(engine.entity, payload.renderer)
        })
      });

    case 'ENGINE_SCENE_LOAD':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, engine), {
          entity: engine.runtime.loadScene(engine.entity, payload.sceneId)
        })
      });

    case 'ENGINE_RENDERER_CHANGES':
      return Object.assign(Object.assign({}, state), {
        [payload.id]: Object.assign(Object.assign({}, engine), {
          entity: Object.assign(Object.assign({}, engine.entity), {
            renderer: Object.assign(Object.assign({}, engine.entity.renderer), {
              entity: engine.entity.renderer.runtime.changes(engine.entity.renderer.entity, payload.changes)
            })
          })
        })
      });
  }

  return state;
};

export const ogodReducer = {
  engines: engineReducer,
  instances: instanceReducer,
  scenes: sceneReducer,
  resources: resourceReducer
}; //# sourceMappingURL=reducer.js.map