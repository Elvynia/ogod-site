import { combineEpics, ofType } from "../../../../../redux-observable/lib/esm/index.js";
import { empty, of } from "../../../../../rxjs/_esm5/index.js";
import { auditTime, filter, map, mapTo, merge, mergeMap, pluck, switchMap, take, takeUntil, tap } from "../../../../../rxjs/_esm5/operators/index.js";
import { AUDIT_TIME_DEFAULT } from "../constants.js";
import { addToScene, initializeInstance, loadEngineScene, loadInstance, loadResource, loadScene, updateInstances, loadEngine, changeScene } from "./action.js";

const debugActionsEpic = (action$, _state$) => action$.pipe(filter(({
  type
}) => type !== 'INSTANCE_UPDATE' && type !== 'INSTANCE_CHANGES' && type !== 'INSTANCE_CHANGES_PROPERTY'), tap(action => console.log(action.type, action.payload)), switchMap(() => empty()));

const debugChangesEpic = action$ => action$.pipe(filter(({
  type
}) => type === 'INSTANCE_CHANGES' || type === 'INSTANCE_CHANGES_PROPERTY'), auditTime(1000), tap(action => console.log('%s: ', action.type, action.payload)), switchMap(() => empty()));

const debugUpdatesEpic = action$ => action$.pipe(ofType('INSTANCE_UPDATE'), auditTime(1000), tap(action => console.log('%s: ', action.type, action.payload)), switchMap(() => empty()));

const resourceCreateSharedEpic = (action$, state$) => action$.pipe(ofType('RESOURCE_CREATE'), filter(({
  payload
}) => !payload.sceneId), map(({
  payload
}) => loadResource(payload.name)));

const resourceCreateEpic = (action$, state$) => action$.pipe(ofType('RESOURCE_CREATE'), filter(({
  payload
}) => !!payload.sceneId), switchMap(({
  payload
}) => state$.pipe(filter(state => !!state.scenes[payload.sceneId]), map(state => state.scenes[payload.sceneId]), map(state => [state.entity, payload.name]), take(1))), filter(value => !value[0].loadMap.lazy), map(value => loadResource(value[1])));

const resourceLoadEpic = (action$, state$) => action$.pipe(ofType('RESOURCE_LOAD'), switchMap(({
  payload
}) => state$.pipe(map(state => state.resources[payload.name]), take(1))), mergeMap(state => state.runtime.load(state.entity, state$)));

const instanceCreateEpic = (action$, state$) => action$.pipe(ofType('INSTANCE_CREATE'), filter(({
  payload
}) => !!state$.value.scenes[payload.sceneId]), filter(({
  payload
}) => state$.value.scenes[payload.sceneId].entity.loaded || state$.value.scenes[payload.sceneId].entity.loading), map(({
  payload
}) => loadInstance(payload.id)));

const instanceAddToSceneEpic = (action$, state$) => action$.pipe(ofType('INSTANCE_CREATE', 'INSTANCE_CLONE'), mergeMap(({
  payload
}) => state$.pipe(map(state => state.instances[payload.id].entity), filter(entity => entity.loaded && entity.initialized), take(1), mapTo(payload))), map(payload => addToScene(payload.sceneId, payload.id, payload.zIndex)));

const instanceLoadEpic = (action$, state$) => action$.pipe(ofType('INSTANCE_LOAD'), switchMap(({
  payload
}) => state$.pipe(map(state => state.instances[payload.id]), take(1))), mergeMap(instance => instance.runtime.load(instance.entity, state$)));

const instanceLoadedEpic = action$ => action$.pipe(ofType('INSTANCE_LOADED'), map(({
  payload
}) => initializeInstance(payload.id, payload.engineId, payload.sceneId)));

const sceneCreateEpic = action$ => action$.pipe(ofType('SCENE_CREATE'), filter(({
  payload
}) => !payload.state.entity.loadMap.lazy), map(({
  payload
}) => loadScene(payload.id)));

const sceneLoadEpic = (action$, state$) => action$.pipe(ofType('SCENE_LOAD'), switchMap(({
  payload
}) => state$.pipe(pluck('scenes'), map(scenes => scenes[payload.id]), take(1))), mergeMap(scene => scene.runtime.load(scene.entity, state$)));

const sceneStartEpic = (action$, state$) => action$.pipe(ofType('SCENE_START'), switchMap(({
  payload
}) => state$.pipe(pluck('scenes'), map(scenes => scenes[payload.id]), take(1))), switchMap(scene => state$.pipe(pluck('instances'), map(instances => scene.entity.children.map(child => instances[child.id])), map(instances => ({
  instances,
  scene
})), take(1))), map(arg => changeScene(arg.scene.entity.id, arg.scene.runtime.start(arg.scene.entity, arg.instances))));

const sceneStopEpic = (action$, state$) => action$.pipe(ofType('SCENE_STOP'), switchMap(({
  payload
}) => state$.pipe(pluck('scenes'), map(scenes => scenes[payload.id]), take(1))), switchMap(scene => state$.pipe(pluck('instances'), map(instances => scene.entity.children.map(child => instances[child.id])), map(instances => ({
  instances,
  scene
})), take(1))), map(arg => changeScene(arg.scene.entity.id, arg.scene.runtime.stop(arg.scene.entity, arg.instances))));

const sceneNavEpic = (action$, state$) => action$.pipe(ofType('SCENE_NEXT', 'SCENE_BACK'), switchMap(({
  type,
  payload
}) => state$.pipe(filter(state => !!state.engines[payload.engineId]), map(state => state.engines[payload.engineId].entity.currentScene), switchMap(sceneId => state$.pipe(take(1), filter(state => state.scenes[sceneId] && !!state.scenes[sceneId].entity.loadMap), map(state => state.scenes[sceneId].entity.loadMap), map(loadMap => ({
  engineId: payload.engineId,
  sceneId: type === 'SCENE_BACK' ? loadMap.onBack : loadMap.onNext
})))), take(1))), switchMap(arg => arg.sceneId ? of(loadEngineScene(arg.engineId, arg.sceneId)) : empty()));

const engineCreateEpic = (action$, state$) => action$.pipe(ofType('ENGINE_CREATE'), map(({
  payload
}) => loadEngine(payload.id)));

const engineLoadEpic = (action$, state$) => action$.pipe(ofType('ENGINE_LOAD'), switchMap(({
  payload
}) => state$.pipe(pluck('engines'), map(engines => engines[payload.id]), take(1))), mergeMap(engine => engine.runtime.load(engine.entity, state$)));

const engineStartEpic = (action$, state$) => action$.pipe(ofType('ENGINE_START'), switchMap(({
  payload
}) => state$.pipe(filter(state => state.engines[payload.id] != null && state.engines[payload.id].entity.currentScene != null), map(state => state.engines[payload.id].entity.currentScene), take(1))), merge(action$.pipe(ofType('ENGINE_SCENE_LOAD'), map(action => action.payload.sceneId))), switchMap(sceneId => state$.pipe(filter(state => !!state.scenes[sceneId]), map(state => state.scenes[sceneId].entity), take(1))), switchMap(entity => entity.changes.pipe(auditTime(AUDIT_TIME_DEFAULT), mergeMap(changes => {
  if (changes.hasAny) {
    entity.changes.reset();
    return of(updateInstances(entity.engineId, changes));
  } else {
    return empty();
  }
}), takeUntil(action$.pipe(ofType('ENGINE_STOP'), filter(action => entity.engineId === action.payload.id))))));

let epics = [resourceCreateSharedEpic, resourceCreateEpic, resourceLoadEpic, instanceCreateEpic, instanceAddToSceneEpic, instanceLoadEpic, instanceLoadedEpic, sceneCreateEpic, sceneLoadEpic, sceneStartEpic, sceneStopEpic, sceneNavEpic, engineCreateEpic, engineLoadEpic, engineStartEpic];

if (window.process.env.NODE_ENV !== 'production') {
  epics.push(debugActionsEpic);

  if (window.process.env.NODE_ENV === 'development') {
    epics.push(debugChangesEpic);
    epics.push(debugUpdatesEpic);
  }
}

export const ogodEpic = combineEpics(...epics); //# sourceMappingURL=epic.js.map