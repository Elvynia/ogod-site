var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

import { customElement, html, LitElement, property } from "../../../../../lit-element/lit-element.js";
import { loadEngineRenderer, changesEngineRenderer } from "../redux/action.js";
import { ogodStore } from "../redux/store.js";
import { lookupByClassName } from "../utils.js";
let OgodRendererElement = class OgodRendererElement extends LitElement {
  constructor() {
    super();
    this.width = '300px';
    this.height = '150px';
    this.resolution = devicePixelRatio;
  }

  get engineId() {
    if (this._engineId === undefined) {
      this._engineId = lookupByClassName(this, 'ogodEngine', 'id');
    }

    return this._engineId;
  }

  getEntity() {
    return {
      target: this.target,
      resolution: this.resolution,
      width: this.pixelWidth,
      height: this.pixelHeight,
      initialized: false
    };
  }

  getRuntime() {
    if (!this.runtime) {
      this.runtime = this.impl();
    }

    return this.runtime;
  }

  get pixelWidth() {
    return this.target && this.target.getBoundingClientRect().width;
  }

  get pixelHeight() {
    return this.target && this.target.getBoundingClientRect().height;
  }

  render() {
    return html`
        <style rel="stylesheet">
            :host {
                display: block;
            }
            #ogodHost {
                position: relative;
            }
            #scenes::slotted(ogod-scene), #scenes::slotted(.ogodScene), 
                #scenes::slotted(.ogodSceneHost), #loader::slotted(*), ogod-loading {
                position: absolute;
            }
            #loader::slotted(*), ogod-loading {
                top: 0;
            }
            #scenes::slotted(ogod-scene), #scenes::slotted(.ogodScene), 
                #scenes::slotted(.ogodSceneHost) {
                visibility: hidden;
            }
            #scenes::slotted(.ogodActive) {
                visibility: visible;
            }
            #scenes::slotted(.ogodTop) {
                top: 0;
            }
            #scenes::slotted(.ogodLeft) {
                left: 0;
            }
            #scenes::slotted(.ogodBottom) {
                bottom: 0;
            }
            #scenes::slotted(.ogodRight) {
                right: 0;
            }
            #scenes::slotted(.ogodCover) {
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
            }
            #scenes::slotted(.ogodCenter) {
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            #view::slotted(.ogodView), #view .ogodView {
                position: relative;
                width: ${this.width};
                height: ${this.height};
                z-index: 0
            }
        </style>
        <div id="ogodHost" style="width: ${this.width};height: ${this.height};">
            <slot id="view" name="view">
                ${this.targetTemplate ? this.targetTemplate : ''}
            </slot>
            <slot id="loader" name="loader">
                <ogod-loading></ogod-loading>
            </slot>
            <slot id="scenes"></slot>
        </div>
    `;
  }

  firstUpdated() {
    if (!this.target) {
      this.target = this.querySelector('.ogodView') || this.shadowRoot.querySelector('.ogodView');
    }
  }

  async updated(changes) {
    await this.updateComplete;
    let changed = {};

    if (changes.has('target') && changes.get('target') !== this.target) {
      changed.target = this.target;
    }

    if (changes.has('width') && changes.get('width') !== this.width) {
      changed.width = this.pixelWidth;
    }

    if (changes.has('height') && changes.get('height') !== this.height) {
      changed.height = this.pixelHeight;
    }

    if (changes.has('resolution') && changes.get('resolution') !== this.resolution) {
      changed.resolution = this.resolution || devicePixelRatio;
    }

    if (Object.keys(changed).length > 0) {
      ogodStore.dispatch(changesEngineRenderer(this.engineId, changed));
    }
  }

  async connectedCallback() {
    this.classList.add('ogodRenderer');
    super.connectedCallback();

    if (!this.impl) {
      throw new Error('Cannot use ogod-renderer without a function that return the runtime implementation (impl=[[func]]).');
    }

    await super.updateComplete;
    ogodStore.dispatch(loadEngineRenderer(this.engineId, {
      entity: this.getEntity(),
      runtime: this.getRuntime()
    }));
  }

};

__decorate([property({
  attribute: false
})], OgodRendererElement.prototype, "impl", void 0);

__decorate([property({
  attribute: false
})], OgodRendererElement.prototype, "target", void 0);

__decorate([property({
  reflect: true
})], OgodRendererElement.prototype, "width", void 0);

__decorate([property({
  reflect: true
})], OgodRendererElement.prototype, "height", void 0);

__decorate([property()], OgodRendererElement.prototype, "resolution", void 0);

OgodRendererElement = __decorate([customElement('ogod-renderer')], OgodRendererElement);
export { OgodRendererElement }; //# sourceMappingURL=ogod-renderer.js.map