import { of } from "../../../../../../rxjs/_esm5/index.js";
import { filter, mapTo, take } from "../../../../../../rxjs/_esm5/operators/index.js";
import { sceneChildrenSorter } from "../../../core/index.js";
import { loadedScene } from "../../../core/redux/action.js";
import { OgodSceneRuntime } from "../../../core/state/ogod-scene.js";
import { OgodSceneChanges } from "../../../core/state/ogod-scene-changes.js";
export class DefaultSceneRuntime extends OgodSceneRuntime {
  load(entity, state$) {
    if (entity.loadMap) {
      let resourcesToLoad = entity.loadMap && entity.loadMap.resources || [];
      let instancesToLoad = entity.loadMap && entity.loadMap.instances || [];
      return state$.pipe(filter(state => {
        for (let resource of resourcesToLoad) {
          if (!state.resources[resource] || !state.resources[resource].entity.loaded) {
            return false;
          }
        }

        return true;
      }), filter(state => {
        for (let instance of instancesToLoad) {
          if (!state.instances[instance] || !state.instances[instance].entity.initialized || state.scenes[entity.id].entity.children.findIndex(child => child.id === instance) < 0) {
            return false;
          }
        }

        return true;
      }), take(1), mapTo(loadedScene(entity.id)));
    } else {
      return of(loadedScene(entity.id));
    }
  }

  start(entity, instances) {
    let changes = new OgodSceneChanges();
    instances.forEach(instance => changes.modified(instance.entity.id, instance.runtime.start(instance.entity)));
    entity.changes.next(changes);
    return Object.assign(Object.assign({}, entity), {
      started: true
    });
  }

  stop(entity, instances) {
    let changes = new OgodSceneChanges();
    instances.forEach(instance => changes.modified(instance.entity.id, instance.runtime.stop(instance.entity)));
    entity.changes.next(changes);
    return Object.assign(Object.assign({}, entity), {
      started: false
    });
  }

  changes(entity, changes) {
    return Object.assign(Object.assign({}, entity), changes);
  }

  add(entity, id, zIndex) {
    return Object.assign(Object.assign({}, entity), {
      children: entity.children.concat([{
        id,
        zIndex
      }]).sort(sceneChildrenSorter)
    });
  }

  remove(entity, id) {
    return Object.assign(Object.assign({}, entity), {
      children: entity.children.filter(child => child.id !== id).sort(sceneChildrenSorter)
    });
  }

  update(entity, instances, delta) {
    if (entity.children) {
      let changes = new OgodSceneChanges();
      instances.filter(i => i.entity.loaded).forEach(instance => {
        let childEntity = instance.runtime.update(instance.entity, delta);

        if (childEntity !== instance.entity) {
          changes.modified(instance.entity.id, childEntity);
        }
      });
      entity.changes.next(changes);
    }
  }

  destroy(_entity) {}

} //# sourceMappingURL=default-scene.js.map