var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { OgodInstanceElement } from "../../../core/dist/index.js";
import { customElement, html } from "../../../../lit-element/lit-element.js";
import { Float32BufferAttribute } from "../../../../three/build/three.module.js";
import { ThreePointsRuntime } from "../state/three-points-runtime.js";
let ThreePointsElement = class ThreePointsElement extends OgodInstanceElement {
  constructor() {
    super();

    this.impl = () => new ThreePointsRuntime();
  }

  getEntity() {
    return Object.assign({}, super.getEntity(), {
      geometry: this.geometry.fixture,
      material: this.material.fixture
    });
  }

  render() {
    return html`
        <slot>
            <three-buffer-geometry></three-buffer-geometry>
            <three-points-material></three-points-material>
        </slot>`;
  }

  firstUpdated() {
    super.firstUpdated();
    this.geometry = this.querySelector('.threeGeometry') || this.shadowRoot.querySelector('.threeGeometry');
    this.material = this.querySelector('.threeMaterial') || this.shadowRoot.querySelector('.threeMaterial');
  }

  connectedCallback() {
    const _super = Object.create(null, {
      updateComplete: {
        get: () => super.updateComplete
      },
      connectedCallback: {
        get: () => super.connectedCallback
      }
    });

    return __awaiter(this, void 0, void 0, function* () {
      _super.updateComplete.then(() => {
        let vertices = [];

        for (let i = 0; i < 10000; i++) {
          let x = Math.random() * 2000 - 1000;
          let y = Math.random() * 2000 - 1000;
          let z = Math.random() * 2000 - 1000;
          vertices.push(x, y, z);
        }

        this.geometry.fixture.addAttribute('position', new Float32BufferAttribute(vertices, 3));
      });

      _super.connectedCallback.call(this);
    });
  }

};
ThreePointsElement = __decorate([customElement('three-points')], ThreePointsElement);
export { ThreePointsElement }; //# sourceMappingURL=three-points.js.map