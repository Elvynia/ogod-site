var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

import { OgodSceneChanges } from "../state/ogod-scene-changes.js";

const resourceReducer = function (state = {}, action) {
  let payload = action.payload;

  switch (action.type) {
    case 'RESOURCE_CREATE':
      return Object.assign({}, state, {
        [payload.name]: payload.state
      });

    case 'RESOURCE_LOAD':
      return Object.assign({}, state, {
        [payload.name]: Object.assign({}, state[payload.name], {
          entity: Object.assign({}, state[payload.name].entity, {
            loading: true
          })
        })
      });

    case 'RESOURCE_LOADED':
      return Object.assign({}, state, {
        [payload.name]: Object.assign({}, state[payload.name], {
          entity: Object.assign({}, state[payload.name].entity, {
            loading: false,
            loaded: true
          })
        })
      });

    case 'RESOURCE_DESTROY':
      state[payload.name].runtime.destroy(state[payload.name].entity);

      let _a = payload.name,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;
  }

  return state;
};

const instanceReducer = function (state = {}, action) {
  let payload = action.payload;
  let instance = state[payload && payload.id];

  switch (action.type) {
    case 'INSTANCE_CREATE':
      return Object.assign({}, state, {
        [payload.id]: payload.state
      });

    case 'INSTANCE_LOAD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, state[payload.id], {
          entity: Object.assign({}, state[payload.id].entity, {
            loading: true
          })
        })
      });

    case 'INSTANCE_LOADED':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, state[payload.id], {
          entity: Object.assign({}, state[payload.id].entity, {
            loading: false,
            loaded: true
          })
        })
      });

    case 'INSTANCE_INITIALIZE':
      let entity = state[payload.id].runtime.initialize(state[payload.id].entity);
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, state[payload.id], {
          entity
        })
      });

    case 'INSTANCE_DESTROY':
      state[payload.id].runtime.destroy(state[payload.id].entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;

    case 'INSTANCE_UPDATE':
      let modified = payload.changes instanceof OgodSceneChanges && payload.changes._modified;
      Object.keys(modified).forEach(key => {
        let newProps = Object.assign({}, state[key].entity.properties, modified[key].properties);
        state[key] = {
          entity: Object.assign({}, state[key].entity, modified[key], {
            properties: newProps
          }),
          runtime: state[key].runtime
        };
      });
      break;

    case 'INSTANCE_CHANGES':
      let changeEntity = Object.assign({}, instance.entity, payload.changes);
      let newEntity = instance.runtime.changes(changeEntity);

      if (changeEntity !== newEntity) {
        return Object.assign({}, state, {
          [payload.id]: Object.assign({}, state[payload.id], {
            entity: Object.assign({}, state[payload.id].entity, newEntity)
          })
        });
      }

      break;

    case 'INSTANCE_CHANGES_PROPERTY':
      let propName = payload.changes.name;
      let changeState = Object.assign({}, instance.entity.properties[propName], {
        entity: Object.assign({}, instance.entity.properties[propName].entity, payload.changes)
      });
      let newPropState = instance.runtime.changesProperty(instance.entity, changeState);

      if (changeState !== newPropState) {
        return Object.assign({}, state, {
          [payload.id]: Object.assign({}, state[payload.id], {
            entity: Object.assign({}, state[payload.id].entity, {
              properties: Object.assign({}, state[payload.id].entity.properties, {
                [propName]: newPropState
              })
            })
          })
        });
      }

      break;
  }

  return state;
};

const sceneReducer = function (state = {}, action) {
  const payload = action.payload;
  const scene = state[payload && payload.id];

  switch (action.type) {
    case 'SCENE_CREATE':
      return Object.assign({}, state, {
        [payload.id]: payload.state
      });

    case 'SCENE_LOAD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, state[payload.id], {
          entity: Object.assign({}, state[payload.id].entity, {
            loading: true
          })
        })
      });

    case 'SCENE_LOADED':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, state[payload.id], {
          entity: Object.assign({}, state[payload.id].entity, {
            loading: false,
            loaded: true
          })
        })
      });

    case 'SCENE_ADD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, scene, {
          entity: scene.runtime.add(scene.entity, payload.childId, payload.zIndex)
        })
      });

    case 'SCENE_REMOVE':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, scene, {
          entity: scene.runtime.remove(scene.entity, payload.childId)
        })
      });

    case 'SCENE_DESTROY':
      scene.runtime.destroy(scene.entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;
  }

  return state;
};

const engineReducer = function (state = {}, action) {
  let payload = action.payload;
  let engine = state[payload && payload.id];

  switch (action.type) {
    case 'ENGINE_CREATE':
      return Object.assign({}, state, {
        [payload.id]: payload.state
      });

    case 'ENGINE_LOAD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, engine, {
          entity: Object.assign({}, engine.entity, {
            loading: true
          })
        })
      });

    case 'ENGINE_LOADED':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, engine, {
          entity: Object.assign({}, engine.entity, {
            loading: false,
            loaded: true
          })
        })
      });

    case 'ENGINE_START':
      if (!engine.entity.started) {
        return Object.assign({}, state, {
          [payload.id]: {
            entity: engine.runtime.start(engine.entity),
            runtime: engine.runtime
          }
        });
      } else {
        console.warn('Cannot start engine if already started');
        return state;
      }

    case 'ENGINE_STOP':
      if (engine.entity.started) {
        return Object.assign({}, state, {
          [payload.id]: {
            entity: engine.runtime.stop(engine.entity),
            runtime: engine.runtime
          }
        });
      } else {
        console.warn('Cannot stop engine if already stopped');
        return state;
      }

    case 'ENGINE_PAUSE':
      return Object.assign({}, state, {
        [payload.id]: {
          entity: engine.runtime.pause(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_RESUME':
      return Object.assign({}, state, {
        [payload.id]: {
          entity: engine.runtime.resume(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_TOGGLE_PAUSE':
      return Object.assign({}, state, {
        [payload.id]: {
          entity: engine.entity.paused ? engine.runtime.resume(engine.entity) : engine.runtime.pause(engine.entity),
          runtime: engine.runtime
        }
      });

    case 'ENGINE_DESTROY':
      state[payload.id].runtime.destroy(state[payload.id].entity);

      let _a = payload.id,
          value = state[_a],
          newState = __rest(state, [typeof _a === "symbol" ? _a : _a + ""]);

      return newState;

    case 'ENGINE_RENDERER_LOAD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, engine, {
          entity: engine.runtime.loadRenderer(engine.entity, payload.renderer)
        })
      });

    case 'ENGINE_SCENE_LOAD':
      return Object.assign({}, state, {
        [payload.id]: Object.assign({}, engine, {
          entity: engine.runtime.loadScene(engine.entity, payload.sceneId)
        })
      });
  }

  return state;
};

export const ogodReducer = {
  engines: engineReducer,
  instances: instanceReducer,
  scenes: sceneReducer,
  resources: resourceReducer
}; //# sourceMappingURL=reducer.js.map