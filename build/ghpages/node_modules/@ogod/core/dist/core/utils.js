import { LitElement } from "../../../../lit-element/lit-element.js";
import { Subscription } from "../../../../rxjs/_esm5/index.js";
export function generateEngineId() {
  return '_' + Math.random().toString(36).substr(2, 9);
}
export class BaseRuntime {}
export class CustomAttribute {}
export class FeatureAttribute extends CustomAttribute {
  async connectedCallback() {
    await this.ownerElement.updateComplete;
    this.ownerElement.addFeature(this.getFeature());
  }

  disconnectedCallback() {}

  changedCallback() {}

}
export function lookupByClassName(el, className, propToRead) {
  let root = el;

  while (root && root.tagName !== 'BODY') {
    if (root.classList && root.classList.contains(className)) {
      return propToRead ? root[propToRead] : root;
    }

    root = root.assignedSlot || root.parentNode || root.host;
  }

  return undefined;
}
export function sceneChildrenSorter(a, b) {
  let zResult = a.zIndex - b.zIndex;

  if (zResult === 0) {
    return a.id.localeCompare(b.id, 'en-US');
  }

  return zResult;
}
export function createObserverOn(target, subscriber) {
  const config = {
    attributes: true,
    attributeOldValue: true,
    characterData: true,
    characterDataOldValue: true,
    childList: true,
    subtree: true
  };
  const observer = new MutationObserver(subscriber);
  observer.observe(target, config);
  return observer;
}
export function createListenerOn(target, event, listener) {
  target.addEventListener(event, listener);
  return {
    target,
    event,
    listener
  };
}
export class ReleasableLitElement extends LitElement {
  constructor() {
    super();
    this.subscriptions = new Array();
  }

  releaseOnDestroy(subOrObs) {
    this.subscriptions.push(subOrObs);
  }

  disconnectedCallback() {
    this.subscriptions.forEach(subOrObs => {
      if (subOrObs instanceof MutationObserver) {
        subOrObs.disconnect();
      } else if (subOrObs instanceof Subscription) {
        subOrObs.unsubscribe();
      } else if (subOrObs.event && subOrObs.target) {
        subOrObs.target.removeEventListener(subOrObs.event, subOrObs.listener);
      }
    });
    super.disconnectedCallback();
  }

}
; //# sourceMappingURL=utils.js.map