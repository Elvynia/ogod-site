import { animationFrameScheduler, defer, of } from "../../../../../../rxjs/_esm5/index.js";
import { filter, map, mapTo, pairwise, repeat, switchMap, take } from "../../../../../../rxjs/_esm5/operators/index.js";
import { loadedEngine } from "../../../core/redux/action.js";
import { ogodState$ } from "../../../core/redux/store.js";
import { OgodEngineRuntime } from "../../../core/state/ogod-engine.js";
export const requestAnimationFrame$ = defer(() => of(animationFrameScheduler.now(), animationFrameScheduler).pipe(repeat(), map(start => animationFrameScheduler.now() - start), pairwise(), map(time => time[1] - time[0])));
export class DefaultEngineRuntime extends OgodEngineRuntime {
  load(entity, state$) {
    let scenesToLoad = [];

    if (entity.loadMap && entity.loadMap.scenes) {
      scenesToLoad.concat(entity.loadMap.scenes);
    }

    if (entity.loadMap && entity.loadMap.initScene) {
      scenesToLoad.push(entity.loadMap.initScene);
      entity.currentScene = entity.loadMap.initScene;
    } else if (scenesToLoad.length > 0) {
      entity.currentScene = scenesToLoad[0];
    }

    let resourcesToLoad = entity.loadMap && entity.loadMap.resources || [];
    return state$.pipe(filter(state => {
      for (let resource of resourcesToLoad) {
        if (!state.resources[resource] || !state.resources[resource].entity.loaded) {
          return false;
        }
      }

      return true;
    }), filter(state => {
      for (let scene of scenesToLoad) {
        if (!state.scenes[scene] || !state.scenes[scene].entity.loaded) {
          return false;
        }
      }

      return true;
    }), map(state => state.engines[entity.id].entity), filter(engine => engine.renderer && engine.renderer.entity.initialized), take(1), mapTo(loadedEngine(entity.id)));
  }

  start(entity) {
    this.sub = this.animationObservable(entity).subscribe(arg => {
      if (!arg.engine.paused) {
        this.renderAndUpdate(arg.engine, arg.scene, arg.instances, arg.delta);
      }
    });
    return Object.assign({}, entity, {
      started: true
    });
  }

  loadRenderer(entity, renderer) {
    let rEntity = renderer.runtime.initialize(renderer.entity);
    return Object.assign({}, entity, {
      renderer: Object.assign({}, renderer, {
        entity: rEntity
      })
    });
  }

  loadScene(entity, sceneId) {
    entity = Object.assign({}, entity, {
      currentScene: sceneId
    });
    this.sub = this.animationObservable(entity).pipe(take(1)).subscribe(arg => {
      this.renderAndUpdate(arg.engine, arg.scene, arg.instances, arg.delta);
    });
    return entity;
  }

  pause(entity) {
    return Object.assign({}, entity, {
      paused: true
    });
  }

  resume(entity) {
    return Object.assign({}, entity, {
      paused: false
    });
  }

  stop(entity) {
    if (this.sub) {
      this.sub.unsubscribe();
      this.sub = undefined;
    }

    return Object.assign({}, entity, {
      started: false
    });
  }

  destroy(entity) {
    if (entity.started) {
      this.stop(entity);
    }

    entity.renderer.runtime.destroy(entity.renderer.entity);
  }

  animationObservable(entity) {
    return requestAnimationFrame$.pipe(switchMap(delta => ogodState$().pipe(filter(state => !!state.engines[entity.id]), map(state => state.engines[entity.id].entity), map(engine => ({
      engine,
      delta
    })), take(1))), switchMap(arg => ogodState$().pipe(map(state => state.scenes[arg.engine.currentScene]), map(scene => Object.assign({
      scene
    }, arg)), take(1))), switchMap(arg => ogodState$().pipe(filter(() => !!arg.scene), map(state => arg.scene.entity.children.filter(child => state.instances[child.id]).map(child => state.instances[child.id])), map(instances => Object.assign({
      instances
    }, arg)), take(1))));
  }

  renderAndUpdate(engineEntity, sceneState, instances, delta) {
    engineEntity.renderer.runtime.render(engineEntity.renderer.entity, delta, sceneState, instances);
    sceneState.runtime.update(sceneState.entity, instances, delta);
  }

} //# sourceMappingURL=default-engine.js.map